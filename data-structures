Big O notation and Time complexity

- Time complexity is a way of showing how the runtime of a function increases as a the size of the import increases
    - Linear time complexity  O(n) n = size of inputs
    - constant time complexity O(1) 
    - quadratic time complexity O(n^2) - bubble sort, selection sort, insertion sort, nested loops
    - logarithmic time complexity O(log n) - binary search 
    - exponential time complexity O(2^n) - recursive forks, backtracking, complete search 
    - n-factorial time complexity O(n!) - permutations

"we can buy memory, but you can't buy time"
- Fast runtime is better than efficient memory usage





Linked list
pros
- adding new items
- deleting items
cons
- retrieval
- searching

class Node:
    def __init__(self, val) // constructor in javascript
        self.val = val
        self.next = None  // pointer / null in javascript

class SLL:
    def __init__(self):
        self.head = None
    
    def addtoFront(self, val):
        temp = Node(val)
        temp.next = self.head
        self.head = temp
        return self
    
    def removeHead(self):
        if self.head is None:
            return False
        else:
            temp = self.head
            self.head = self.head.next
            # print(temp)
    
    def addtoBack(self,val):
        pointer = self.head
        if pointer is not None:  // if ( point != null ) javascript
            while pointer.next is not None: // while (point.next != null )
                pointer = pointer.next
            pointer.next = Node(val)
        else:
            self.next = Node(val)
    
    def removefromBack(self,val):
        prepointer = self.head
        pointer = self.head
        if pointer is not None and pointer.next is not None:
            while pointer.next is not None:
                prepointer = pointer
                pointer = pointer.next
            prepointer.next = None
        elif pointer == None:
            print('Error, you have no Node')
            return False
        else:
            self.head = None
    
    def insertAt(self, val, pos):
        runner = self.head
        if (self.head is None) or (pos is 1):
            return False
        if self.head is not None and self.head.next == None:
            self.head = Node(val)
        for i in range(pos - 2) :
            runner = runner.next
            new_node = Node(val)
            runner.next = new_node
            new_node.next = runner
        
    
    def removeAt(self, pos):
        runner = self.head
        if (self.head is None) or (pos is 1):
            return False
        for i in range(pos - 2) :
            if runner.next.next is None:
                runner.next = None
            else: 
                runner = runner.next
        runner.next = runner.next.next


    def retrieveAt(self, pos):
        index = pos - 1
        runner = self.head
        while runner and index: 
            runner = runner.next
            index = index - 1
        if runner:
            return runner.val 
        else: 
            return False






Arrays
continuous block of cells in memory
pros
- retrieving items
cons
- can be tough to handle large items (some languages need to allocate specific number of memory/size of array)





HashTable
object in javascript, dict or dictionary in python, hashmap in javascript
pros
- retrieving and adding
cons
- collisions 






Stack and Queue 

Stack - a list with the restriction that insertion and deletion can be perfromed only from one end, called the top
- "last in first out" (LIFO)
- function callstack, a stack of plates, a bottle of tennis balls, 3 towers of Hanoi
- javascript Arrays :add = .push() / .pop() off top 
- function callstack, recursion
call stack - depth first search 







Queue = first in first out
add to the back enqueuing / dequeueing = remove from from 
breadth first search 

stacks and queue
pro 
- efficient add and remove
con
- limited use cases




Graphs and Trees - graph theory 

binary search tree - each node can have two childen
- left is less then the node, the right is higher than the node




